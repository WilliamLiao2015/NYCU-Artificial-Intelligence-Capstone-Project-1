import { load } from "https://deno.land/std@0.219.1/dotenv/mod.ts"

import { OpenAI } from "npm:openai"

import * as fs from "node:fs"

import {exponentialBackoff} from "./backoff.ts"


const logStream_problem = fs.createWriteStream("problem.log", { flags: "a" });
function logProblem(message: string) {
  logStream_problem.write(message + '\n');
};

const { OPENAI_API_KEY } = await load()
const client = new OpenAI({ apiKey: OPENAI_API_KEY })

const previousReviews = JSON.parse(await Deno.readTextFile("./data/reviews.json")) as ReviewData[]
const systemPrompt = await Deno.readTextFile("./data/system_prompt.txt")


async function getChatGPTResponse({ title, textContent }: NewsData) {
  const prompt = (await Deno.readTextFile("./data/user_prompt.txt")).replace(/{{title}}/g, title).replace(/{{text}}/g, textContent)
  //console.log(prompt)
  const response = await client.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: prompt }
    ],
    max_tokens: 500
  })
  return response.choices[0].message.content
}


let newCount = 0
let errFlag = false
const markers = {
  rating: "- rating:",
  reason: "- reason:",
  conclusion: "- conclusion:"
}
const newsList = JSON.parse(await Deno.readTextFile("./data/news.json")) as NewsData[]
const reviewList = await Promise.all(newsList.slice(1200, 1300).filter(news => !previousReviews.map(pr => pr.link).includes(news.link)).map(async news => {
  try {
    const response = await exponentialBackoff(() => getChatGPTResponse(news), 5, 1000)
    if (!response) return null
    
    const ratingStart = response.indexOf(markers.rating)
    const reasonStart = response.indexOf(markers.reason)
    const conclusionStart = response.indexOf(markers.conclusion)
    
    const ratingStr = response.substring(ratingStart + markers.rating.length, reasonStart).trim()
    const rating = ratingStr.slice(1, -1).split(",").map((item: string) => parseFloat(item.trim()));
    const reason = response.substring(reasonStart + markers.reason.length, conclusionStart).trim()
    const conclusion = response.substring(conclusionStart + markers.conclusion.length).trim() === "1"
    //const reviewArray = parseResponse(response) as object[]
    //const [rating, reason, conclusion] = reviewArray.map((rObj: object) => Object.values(rObj)[0])
    newCount++
    if (newCount % 10 === 0) {
      console.log(`${newCount} new reviews have been generated by GPT till now.`)
    }
    return { ...news, rating, reason, conclusion } as ReviewData
  } catch (error) {
    errFlag = true
    logProblem(`Error parsing ${news.link}`)
    logProblem(error)
    return null
  }
}))
const filteredReviewList = reviewList.filter(review => review !== null) as ReviewData[]
const allReviews = previousReviews.concat(filteredReviewList)


await Deno.writeTextFile("./data/reviews.json", JSON.stringify(allReviews))


console.log(`The number of new reviews is ${newCount}`)

if (errFlag) {
  console.log("There was an error parsing some of the news articles. Please check the log file for more information.")
}
